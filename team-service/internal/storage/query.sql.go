// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addTeamMember = `-- name: AddTeamMember :one
INSERT INTO team_members (
    team_id,
    user_id
)
VALUES ($1, $2)
RETURNING
    id,
    team_id,
    user_id,
    role,
    joined_at
`

type AddTeamMemberParams struct {
	TeamID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) (TeamMember, error) {
	row := q.db.QueryRowContext(ctx, addTeamMember, arg.TeamID, arg.UserID)
	var i TeamMember
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (
    name,
    leader_id,
    event_id
)
VALUES ($1, $2, $3)
RETURNING
    id,
    name,
    leader_id,
    event_id,
    is_ready,
    created_at,
    updated_at
`

type CreateTeamParams struct {
	Name     string
	LeaderID uuid.UUID
	EventID  uuid.UUID
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, createTeam, arg.Name, arg.LeaderID, arg.EventID)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LeaderID,
		&i.EventID,
		&i.IsReady,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT 
    id,
    team_id,
    user_id,
    role,
    joined_at,
    COUNT(*) OVER() AS total_count
FROM team_members
WHERE team_id = $1
ORDER BY joined_at DESC
`

type GetTeamMembersRow struct {
	ID         uuid.UUID
	TeamID     uuid.UUID
	UserID     uuid.UUID
	Role       string
	JoinedAt   sql.NullTime
	TotalCount int64
}

func (q *Queries) GetTeamMembers(ctx context.Context, teamID uuid.UUID) ([]GetTeamMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamMembers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamMembersRow
	for rows.Next() {
		var i GetTeamMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsByEvent = `-- name: GetTeamsByEvent :many
SELECT 
    id,
    name,
    leader_id,
    event_id,
    is_ready,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM teams
WHERE event_id = $1
ORDER BY created_at DESC
LIMIT $2 
OFFSET $3
`

type GetTeamsByEventParams struct {
	EventID uuid.UUID
	Limit   int32
	Offset  int32
}

type GetTeamsByEventRow struct {
	ID         uuid.UUID
	Name       string
	LeaderID   uuid.UUID
	EventID    uuid.UUID
	IsReady    sql.NullBool
	CreatedAt  sql.NullTime
	UpdatedAt  sql.NullTime
	TotalCount int64
}

func (q *Queries) GetTeamsByEvent(ctx context.Context, arg GetTeamsByEventParams) ([]GetTeamsByEventRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamsByEvent, arg.EventID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsByEventRow
	for rows.Next() {
		var i GetTeamsByEventRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LeaderID,
			&i.EventID,
			&i.IsReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inviteMember = `-- name: InviteMember :one
INSERT INTO team_invitations (
    team_id, 
    inviter_id, 
    invited_user_id
)VALUES ($1, $2, $3)
RETURNING 
    id,
    team_id,
    inviter_id,
    invited_user_id,
    status,
    created_at
`

type InviteMemberParams struct {
	TeamID        uuid.UUID
	InviterID     uuid.UUID
	InvitedUserID uuid.UUID
}

type InviteMemberRow struct {
	ID            uuid.UUID
	TeamID        uuid.UUID
	InviterID     uuid.UUID
	InvitedUserID uuid.UUID
	Status        string
	CreatedAt     sql.NullTime
}

func (q *Queries) InviteMember(ctx context.Context, arg InviteMemberParams) (InviteMemberRow, error) {
	row := q.db.QueryRowContext(ctx, inviteMember, arg.TeamID, arg.InviterID, arg.InvitedUserID)
	var i InviteMemberRow
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.InviterID,
		&i.InvitedUserID,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const removeTeamMember = `-- name: RemoveTeamMember :exec
DELETE FROM team_members
WHERE team_id = $1 AND user_id = $2
`

type RemoveTeamMemberParams struct {
	TeamID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) RemoveTeamMember(ctx context.Context, arg RemoveTeamMemberParams) error {
	_, err := q.db.ExecContext(ctx, removeTeamMember, arg.TeamID, arg.UserID)
	return err
}

const respondInvite = `-- name: RespondInvite :one
UPDATE team_invitations
SET status = $1, responded_at = NOW()
WHERE team_id = $2 AND invited_user_id = $3 AND status = 'PENDING'
RETURNING 
    id,
    team_id,
    inviter_id,
    invited_user_id,
    status,
    created_at,
    responded_at
`

type RespondInviteParams struct {
	Status        string
	TeamID        uuid.UUID
	InvitedUserID uuid.UUID
}

func (q *Queries) RespondInvite(ctx context.Context, arg RespondInviteParams) (TeamInvitation, error) {
	row := q.db.QueryRowContext(ctx, respondInvite, arg.Status, arg.TeamID, arg.InvitedUserID)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.InviterID,
		&i.InvitedUserID,
		&i.Status,
		&i.CreatedAt,
		&i.RespondedAt,
	)
	return i, err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE teams
SET 
    name = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING
    id,
    name,
    leader_id,
    event_id,
    is_ready,
    created_at,
    updated_at
`

type UpdateTeamParams struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, updateTeam, arg.ID, arg.Name)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LeaderID,
		&i.EventID,
		&i.IsReady,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
