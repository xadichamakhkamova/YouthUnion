// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const assignRoleToUser = `-- name: AssignRoleToUser :one
INSERT INTO user_roles 
    (
        user_id, 
        role_id
    )
VALUES ($1, $2)
RETURNING
    id,
    user_id,
    role_id,
    assigned_at
`

type AssignRoleToUserParams struct {
	UserID uuid.UUID
	RoleID uuid.UUID
}

func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) (UserRole, error) {
	row := q.db.QueryRowContext(ctx, assignRoleToUser, arg.UserID, arg.RoleID)
	var i UserRole
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoleID,
		&i.AssignedAt,
	)
	return i, err
}

const changePassword = `-- name: ChangePassword :one
UPDATE users
SET password_hash = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING 
    'changed' AS message,
    updated_at
`

type ChangePasswordParams struct {
	ID           uuid.UUID
	PasswordHash string
}

type ChangePasswordRow struct {
	Message   string
	UpdatedAt sql.NullTime
}

func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) (ChangePasswordRow, error) {
	row := q.db.QueryRowContext(ctx, changePassword, arg.ID, arg.PasswordHash)
	var i ChangePasswordRow
	err := row.Scan(&i.Message, &i.UpdatedAt)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles_type
    (
        name, 
        description
    )
VALUES ($1, $2)
RETURNING
    id,
    name,
    description,
    created_at,
    updated_at
`

type CreateRoleParams struct {
	Name        string
	Description sql.NullString
}

type CreateRoleRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (CreateRoleRow, error) {
	row := q.db.QueryRowContext(ctx, createRole, arg.Name, arg.Description)
	var i CreateRoleRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO user_sessions 
    (
        user_id, 
        refresh_token, 
        expires_at
    )
VALUES ($1, $2, $3)
RETURNING
    id,
    user_id,
    refresh_token,
    expires_at,
    created_at
`

type CreateSessionParams struct {
	UserID       uuid.UUID
	RefreshToken string
	ExpiresAt    time.Time
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (UserSession, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.UserID, arg.RefreshToken, arg.ExpiresAt)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    identifier,
    first_name,
    last_name,
    phone_number,
    password_hash,
    faculty,
    course,
    birth_date,
    gender
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING 
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    faculty,
    course,
    birth_date,
    gender,
    created_at,
    updated_at
`

type CreateUserParams struct {
	Identifier   int32
	FirstName    string
	LastName     string
	PhoneNumber  string
	PasswordHash string
	Faculty      sql.NullString
	Course       sql.NullInt32
	BirthDate    string
	Gender       Gender
}

type CreateUserRow struct {
	ID          uuid.UUID
	Identifier  int32
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt32
	BirthDate   string
	Gender      Gender
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Identifier,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.PasswordHash,
		arg.Faculty,
		arg.Course,
		arg.BirthDate,
		arg.Gender,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Faculty,
		&i.Course,
		&i.BirthDate,
		&i.Gender,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :one
DELETE FROM roles_type
WHERE id = $1
RETURNING 'deleted' AS message
`

func (q *Queries) DeleteRole(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteRole, id)
	var message string
	err := row.Scan(&message)
	return message, err
}

const deleteUser = `-- name: DeleteUser :one
UPDATE users
SET deleted_at = $2
WHERE id = $1
RETURNING 
    'deleted' AS message,
    id,
    deleted_at
`

type DeleteUserParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullInt64
}

type DeleteUserRow struct {
	Message   string
	ID        uuid.UUID
	DeletedAt sql.NullInt64
}

func (q *Queries) DeleteUser(ctx context.Context, arg DeleteUserParams) (DeleteUserRow, error) {
	row := q.db.QueryRowContext(ctx, deleteUser, arg.ID, arg.DeletedAt)
	var i DeleteUserRow
	err := row.Scan(&i.Message, &i.ID, &i.DeletedAt)
	return i, err
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT
    id,
    name,
    description,
    created_at,
    updated_at
FROM roles_type
WHERE id = $1
`

type GetRoleByIDRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetRoleByID(ctx context.Context, id uuid.UUID) (GetRoleByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getRoleByID, id)
	var i GetRoleByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT
    id,
    user_id,
    refresh_token,
    expires_at,
    created_at
FROM user_sessions
WHERE refresh_token = $1
`

func (q *Queries) GetSessionByToken(ctx context.Context, refreshToken string) (UserSession, error) {
	row := q.db.QueryRowContext(ctx, getSessionByToken, refreshToken)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT 
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    faculty,
    course,
    birth_date,
    gender,
    created_at,
    updated_at 
FROM users
WHERE id = $1
`

type GetUserByIdRow struct {
	ID          uuid.UUID
	Identifier  int32
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt32
	BirthDate   string
	Gender      Gender
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Faculty,
		&i.Course,
		&i.BirthDate,
		&i.Gender,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByIdentifier = `-- name: GetUserByIdentifier :one
SELECT 
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    password_hash -- bu faqat backendda solishtirish uchun kerak
FROM users
WHERE identifier = $1
`

type GetUserByIdentifierRow struct {
	ID           uuid.UUID
	Identifier   int32
	FirstName    string
	LastName     string
	PhoneNumber  string
	PasswordHash string
}

func (q *Queries) GetUserByIdentifier(ctx context.Context, identifier int32) (GetUserByIdentifierRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByIdentifier, identifier)
	var i GetUserByIdentifierRow
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.PasswordHash,
	)
	return i, err
}

const listRoles = `-- name: ListRoles :many
SELECT
    id,
    name,
    description,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM roles_type
ORDER BY created_at DESC
LIMIT $1 
OFFSET $2
`

type ListRolesParams struct {
	Limit  int32
	Offset int32
}

type ListRolesRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	TotalCount  int64
}

func (q *Queries) ListRoles(ctx context.Context, arg ListRolesParams) ([]ListRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, listRoles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRolesRow
	for rows.Next() {
		var i ListRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRoles = `-- name: ListUserRoles :many
SELECT
    ur.id,
    ur.user_id,
    rt.name AS role_name,
    ur.assigned_at,
    COUNT(*) OVER() AS total_count
FROM user_roles ur
JOIN roles_type rt ON ur.role_id = rt.id
WHERE ur.user_id = $1
LIMIT $2 
OFFSET $3
`

type ListUserRolesParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type ListUserRolesRow struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	RoleName   string
	AssignedAt sql.NullTime
	TotalCount int64
}

func (q *Queries) ListUserRoles(ctx context.Context, arg ListUserRolesParams) ([]ListUserRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserRoles, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserRolesRow
	for rows.Next() {
		var i ListUserRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleName,
			&i.AssignedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    faculty,
    course,
    birth_date,
    gender,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM users
WHERE
    ($1::text IS NULL OR (first_name ILIKE '%' || $1 || '%' OR last_name ILIKE '%' || $1 || '%' OR identifier ILIKE '%' || $1 || '%'))
    AND ($2::text IS NULL OR faculty = $2)
    AND ($3::int IS NULL OR course = $3)
ORDER BY created_at DESC
LIMIT $4
OFFSET $5
`

type ListUsersParams struct {
	Column1 string
	Column2 string
	Column3 int32
	Limit   int32
	Offset  int32
}

type ListUsersRow struct {
	ID          uuid.UUID
	Identifier  int32
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt32
	BirthDate   string
	Gender      Gender
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	TotalCount  int64
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.Faculty,
			&i.Course,
			&i.BirthDate,
			&i.Gender,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeRoleFromUser = `-- name: RemoveRoleFromUser :one
DELETE FROM user_roles
WHERE id = $1 
RETURNING 'removed' AS message
`

func (q *Queries) RemoveRoleFromUser(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, removeRoleFromUser, id)
	var message string
	err := row.Scan(&message)
	return message, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles_type
SET name = $2,
    description = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING
    id,
    name,
    description,
    created_at,
    updated_at
`

type UpdateRoleParams struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
}

type UpdateRoleRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (UpdateRoleRow, error) {
	row := q.db.QueryRowContext(ctx, updateRole, arg.ID, arg.Name, arg.Description)
	var i UpdateRoleRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET 
    first_name = $2,
    last_name = $3,
    phone_number = $4,
    faculty = $5,
    course = $6,
    birth_date = $7,
    gender = $8,
    updated_at = NOW()
WHERE id = $1
RETURNING
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    faculty,
    course,
    birth_date,
    gender,
    created_at,
    updated_at
`

type UpdateUserParams struct {
	ID          uuid.UUID
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt32
	BirthDate   string
	Gender      Gender
}

type UpdateUserRow struct {
	ID          uuid.UUID
	Identifier  int32
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt32
	BirthDate   string
	Gender      Gender
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Faculty,
		arg.Course,
		arg.BirthDate,
		arg.Gender,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Faculty,
		&i.Course,
		&i.BirthDate,
		&i.Gender,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
