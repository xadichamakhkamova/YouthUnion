// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const assignRoleToUser = `-- name: AssignRoleToUser :one
INSERT INTO user_roles 
    (
        user_id, 
        role_id
    )
VALUES ($1, $2)
RETURNING
    id,
    user_id,
    role_id,
    assigned_at
`

type AssignRoleToUserParams struct {
	UserID uuid.UUID
	RoleID uuid.UUID
}

func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) (UserRole, error) {
	row := q.db.QueryRowContext(ctx, assignRoleToUser, arg.UserID, arg.RoleID)
	var i UserRole
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoleID,
		&i.AssignedAt,
	)
	return i, err
}

const changePassword = `-- name: ChangePassword :one
UPDATE users
SET password_hash = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING 'changed' AS message
`

type ChangePasswordParams struct {
	ID           uuid.UUID
	PasswordHash string
}

func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) (string, error) {
	row := q.db.QueryRowContext(ctx, changePassword, arg.ID, arg.PasswordHash)
	var message string
	err := row.Scan(&message)
	return message, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles_type
    (
        name, 
        description
    )
VALUES ($1, $2)
RETURNING
    id,
    name,
    description,
    created_at,
    updated_at
`

type CreateRoleParams struct {
	Name        string
	Description sql.NullString
}

type CreateRoleRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (CreateRoleRow, error) {
	row := q.db.QueryRowContext(ctx, createRole, arg.Name, arg.Description)
	var i CreateRoleRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO user_sessions 
    (
        user_id, 
        refresh_token, 
        expires_at
    )
VALUES ($1, $2, $3)
RETURNING
    id,
    user_id,
    refresh_token,
    expires_at,
    created_at
`

type CreateSessionParams struct {
	UserID       uuid.UUID
	RefreshToken string
	ExpiresAt    time.Time
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (UserSession, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.UserID, arg.RefreshToken, arg.ExpiresAt)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    identifier,
    first_name,
    last_name,
    phone_number,
    password_hash,
    faculty,
    course,
    birth_date,
    gender
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING 
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    faculty,
    course,
    birth_date,
    gender,
    created_at,
    updated_at
`

type CreateUserParams struct {
	Identifier   int32
	FirstName    string
	LastName     string
	PhoneNumber  string
	PasswordHash string
	Faculty      sql.NullString
	Course       sql.NullInt16
	BirthDate    string
	Gender       GenderEnum
}

type CreateUserRow struct {
	ID          uuid.UUID
	Identifier  int32
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt16
	BirthDate   string
	Gender      GenderEnum
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Identifier,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.PasswordHash,
		arg.Faculty,
		arg.Course,
		arg.BirthDate,
		arg.Gender,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Faculty,
		&i.Course,
		&i.BirthDate,
		&i.Gender,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :one
DELETE FROM roles_type
WHERE id = $1
RETURNING 'deleted' AS message
`

func (q *Queries) DeleteRole(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteRole, id)
	var message string
	err := row.Scan(&message)
	return message, err
}

const deleteUser = `-- name: DeleteUser :one
UPDATE users
SET deleted_at = $2
WHERE id = $1
RETURNING 'deleted' AS message
`

type DeleteUserParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullInt64
}

func (q *Queries) DeleteUser(ctx context.Context, arg DeleteUserParams) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteUser, arg.ID, arg.DeletedAt)
	var message string
	err := row.Scan(&message)
	return message, err
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT
    id,
    name,
    description,
    created_at,
    updated_at
FROM roles_type
WHERE id = $1
`

type GetRoleByIDRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetRoleByID(ctx context.Context, id uuid.UUID) (GetRoleByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getRoleByID, id)
	var i GetRoleByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT
    id,
    user_id,
    refresh_token,
    expires_at,
    created_at
FROM user_sessions
WHERE refresh_token = $1
`

func (q *Queries) GetSessionByToken(ctx context.Context, refreshToken string) (UserSession, error) {
	row := q.db.QueryRowContext(ctx, getSessionByToken, refreshToken)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT 
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    faculty,
    course,
    birth_date,
    gender,
    created_at,
    updated_at 
FROM users
WHERE id = $1
`

type GetUserByIdRow struct {
	ID          uuid.UUID
	Identifier  int32
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt16
	BirthDate   string
	Gender      GenderEnum
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Faculty,
		&i.Course,
		&i.BirthDate,
		&i.Gender,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByIdentifier = `-- name: GetUserByIdentifier :one
SELECT 
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    password_hash -- bu faqat backendda solishtirish uchun kerak
FROM users
WHERE identifier = $1
`

type GetUserByIdentifierRow struct {
	ID           uuid.UUID
	Identifier   int32
	FirstName    string
	LastName     string
	PhoneNumber  string
	PasswordHash string
}

func (q *Queries) GetUserByIdentifier(ctx context.Context, identifier int32) (GetUserByIdentifierRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByIdentifier, identifier)
	var i GetUserByIdentifierRow
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.PasswordHash,
	)
	return i, err
}

const listRoles = `-- name: ListRoles :many
SELECT
    id,
    name,
    description,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM roles_type
ORDER BY created_at DESC
LIMIT $2 
OFFSET ($1 - 1) * $2
`

type ListRolesParams struct {
	Column1 interface{}
	Limit   int32
}

type ListRolesRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	TotalCount  int64
}

func (q *Queries) ListRoles(ctx context.Context, arg ListRolesParams) ([]ListRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, listRoles, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRolesRow
	for rows.Next() {
		var i ListRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRoles = `-- name: ListUserRoles :many
SELECT
    ur.id,
    ur.user_id,
    ur.role_id,
    rt.name AS role_name,
    ur.assigned_at,
    COUNT(*) OVER() AS total_count
FROM user_roles ur
JOIN roles_type rt ON ur.role_id = rt.id
WHERE ur.user_id = $1
LIMIT $3 
OFFSET ($2 - 1) * $3
`

type ListUserRolesParams struct {
	UserID  uuid.UUID
	Column2 interface{}
	Limit   int32
}

type ListUserRolesRow struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	RoleID     uuid.UUID
	RoleName   string
	AssignedAt sql.NullTime
	TotalCount int64
}

func (q *Queries) ListUserRoles(ctx context.Context, arg ListUserRolesParams) ([]ListUserRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserRoles, arg.UserID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserRolesRow
	for rows.Next() {
		var i ListUserRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.RoleName,
			&i.AssignedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    faculty,
    course,
    birth_date,
    gender,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM users
ORDER BY created_at DESC
LIMIT $2 
OFFSET ($1 - 1) * $2
`

type ListUsersParams struct {
	Column1 interface{}
	Limit   int32
}

type ListUsersRow struct {
	ID          uuid.UUID
	Identifier  int32
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt16
	BirthDate   string
	Gender      GenderEnum
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	TotalCount  int64
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.Faculty,
			&i.Course,
			&i.BirthDate,
			&i.Gender,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeRoleFromUser = `-- name: RemoveRoleFromUser :one
DELETE FROM user_roles
WHERE id = $1 
RETURNING 'removed' AS message
`

func (q *Queries) RemoveRoleFromUser(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, removeRoleFromUser, id)
	var message string
	err := row.Scan(&message)
	return message, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles_type
SET name = $2,
    description = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING
    id,
    name,
    description,
    created_at,
    updated_at
`

type UpdateRoleParams struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
}

type UpdateRoleRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (UpdateRoleRow, error) {
	row := q.db.QueryRowContext(ctx, updateRole, arg.ID, arg.Name, arg.Description)
	var i UpdateRoleRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET 
    first_name = $2,
    last_name = $3,
    phone_number = $4,
    faculty = $5,
    course = $6,
    birth_date = $7,
    gender = $8,
    updated_at = NOW()
WHERE id = $1
RETURNING
    id,
    identifier,
    first_name,
    last_name,
    phone_number,
    faculty,
    course,
    birth_date,
    gender,
    created_at,
    updated_at
`

type UpdateUserParams struct {
	ID          uuid.UUID
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt16
	BirthDate   string
	Gender      GenderEnum
}

type UpdateUserRow struct {
	ID          uuid.UUID
	Identifier  int32
	FirstName   string
	LastName    string
	PhoneNumber string
	Faculty     sql.NullString
	Course      sql.NullInt16
	BirthDate   string
	Gender      GenderEnum
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Faculty,
		arg.Course,
		arg.BirthDate,
		arg.Gender,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Faculty,
		&i.Course,
		&i.BirthDate,
		&i.Gender,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
